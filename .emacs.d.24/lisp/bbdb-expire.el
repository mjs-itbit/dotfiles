;;; bbdb-expire.el --- expiry and expire-proof entries for the BBDB

;;; Copyright (C) 2000 -- 2005 Nix <nix@esperi.org.uk>.

;; Author: Nix <nix@esperi.org.uk>
;; Created: 2000-09-17
;; Last modified: 2005-02-23
;; Keywords: mail news
;; Version: $Revision: 1.9 $

;; This file is not part of XEmacs, or GNU Emacs.

;; This library is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; It is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
;; License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this library; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
;; 02111-1307, USA.

;;; Commentary:

;; This file implements expiry of BBDB databases, to stop them getting too
;; fantastically bloated. Only specific entries are retained across expiry.

;; To use:

;; Load it, and run `bbdb-expire-initialize'. This does all the grunt work
;; of setting up the package, and does an expiry run. It might take several
;; seconds to run.

;; To expire the BBDB at any time, run `bbdb-expire-bbdb'.

;; Everything else happens automagically.

;; Detail:

;; Each entry is passed through each function in the
;; `bbdb-expire-expiry-functions' in turn; if any return t it is a candicate
;; for expiry; but if any of the functions in the
;; `bbdb-expire-preservation-functions' return t, it is not expired after all.
;; (This scheme allows functions to say `I don't care' as well as `expire
;; me now' and `do not expire me'.)
;;
;; One function is on `bbdb-expire-expiry-functions' by default;
;; `bbdb-expire-record-old-p'.
;; Two functions are on `bbdb-expire-preservation-functions' by default;
;; `bbdb-expire-field-permanent-p' and `bbdb-expire-field-notes-p'.
;;
;; Together, these ensure that old records without a `notes' or a
;; `permanent' field are expired; the field-checking functions are
;; generated by a macro, `bbdb-expire-field-foo-p'.
;;
;; `permanent' fields are added by the `bbdb-expire-make-permanent'
;; function, which calls the functions in the
;; `bbdb-expire-make-permanent-functions' in a similar fashion to the
;; way in which `bbdb-expire-expiry-functions' is called. If any function
;; in this list returns t, a `permanent' field is added to the current
;; record. There is no way for functions to remove `permanent' fields
;; in this scheme (otherwise the two could get into add-and-remove wars.)
;;
;; One function is on the `bbdb-expire-make-permanent-functions' list
;; by default: `bbdb-expire-permanent-address-matches-p', which
;; returns t if the address is matched in the `bbdb-expire-permanent-regexp'.
;; (If you just want to match a bunch of addresses, this regexp is populated
;; if nil from the set of static substrings in `bbdb-expire-permanent-file'
;; at BBDB initialization time.)
;;
;; There are some more functions too, that are not used by default:
;;
;; `bbdb-expire-record-noname-p': Meant to be added to the
;;`bbdb-expire-expiry-functions', this function expires records that have
;; no first or last name associated with them. (These are often associated
;; with spammers.)
;;
;; `bbdb-expire-record-single-hit-p', which when added to the
;; `bbdb-expire-expiry-functions' arranges to delete records that have only
;; been accessed once earlier than other records: they're deleted after
;; `bbdb-expire-this-old-single-hit' days. (These are often spammers that
;; slipped through the net and are forging their email addresses.)

;; To do:

;; (perhaps) Fully integrate into the BBDB. No matter what, `permanent' and
;; `last-access' should remain user fields (i.e. this should not trigger a
;; new revision of the BBDB file format), because those fields are updated by
;; optional predicate functions that can be removed and/or replaced with
;; anything else the user desires.

;; Add some kind of object-based system for predicate registration,
;; like Gnus's `nnoo'. We really need this before the next item can be
;; safely implemented, so we know which functions are predicates and which
;; are not.

;; Add customize support.

;; I have received reports that bbdb-expire works with GNU Emacs, although
;; I don't use it myself. if bbdb-expire doesn't work for you on GNU Emacs
;; or XEmacs, please tell me.

;; You *do* need a reasonably recent Gnus for bbdb-expire to work, as only
;; Gnus-5.8.x includes `time-date.el'.

;;; Requirements:

(require 'bbdb)
(require 'bbdb-com)
(require 'bbdb-hooks)
(require 'time-date)
(require 'advice)

(require 'cl)

;;; User-configurable variables.

(defvar bbdb-expire-this-old 90
  "Expire entries in the BBDB that have not been referenced for this many days.
Used by the `bbdb-expire-record-old-p' function.")

(defvar bbdb-expire-this-old-single-hit 7
  "Single-hit BBDB expiry time.

Expire entries in the BBDB that have not been referenced for this many days,
and who have never been referenced since creation.")

(defvar bbdb-expire-automatic-interval (* 60 60 24)
  "Automatically expire the BBDB every this many seconds, or never if nil.")

(defvar bbdb-expire-expiry-functions '(bbdb-expire-record-old-p)
  "Functions to call to determine if a record is expirable or not.
Each function is called with one parameter, the record to test for
expirable status; it should return t if the record is eligible for
expiry.")

(defvar bbdb-expire-preservation-functions '(bbdb-expire-field-permanent-p
                                             bbdb-expire-field-notes-p)
  "Functions to call to determine if a record should be preserved from expiry.
Each function is called with one parameter, the record to test for preservable
status; it should return t if the record should never be expired.")

(defvar bbdb-expire-suppress-access-time-update nil
  "Whether to update last-access times on BBDB records.

You should bind this variable, not set it; setting it will break time-
based expiry completely. It should only be set when changes need to be
automatically made to BBDB records which the user will not care directly
about.")

(defvar bbdb-expire-permanent-regexp nil
  "A regexp matching addresses of entries that should not expire.
If nil, initialized from the `bbdb-expire-permanent-file' when
`bbdb-expire-initialize' is called.")

(defvar bbdb-expire-permanent-file nil
  "A file containing rooted regexps matching addresses of permanent entries;
That is, entries that should not expire, one address per line.
Only consulted at `bbdb-expire-initialize' time, and only if
`bbdb-expire-permanent-regexp' is nil.")

(defvar bbdb-expire-make-permanent-functions '(bbdb-expire-permanent-address-matches-p)
  "Functions to call to determine if a record is to be marked permanent.
Each function is called with one parameter, the record to test for
permanentness; it should return t if the record is to be marked
permanent.")

(defvar bbdb-expire-load-hook nil
  "Normal hook run at bbdb-expire load time.")

(defvar bbdb-expire-initialize-hook '(bbdb-expire-initialize-bbdb-expire-record-old-p
                                      bbdb-expire-initialize-permanent)
  "Normal hook run at bbdb-expire initialization time.")

(defvar bbdb-expire-pre-expire-hook nil
  "Normal hook run at bbdb expiry time, before expiry begins.")

(defvar bbdb-expire-post-expire-hook nil
  "Normal hook run at bbdb expiry time, after expiry ends.")

(if (boundp 'bbdb-display-layout-alist)
    (defvar bbdb-expire-autohide-variables
      '((last-access (one-line multi-line pop-up-multi-line))
        (expire-just-created (one-line multi-line pop-up-multi-line))
        (permanent (one-line pop-up-multi-line)))
      "When to hide the special BBDB expiry fields.
A list of mappings from variable names to the layouts to hide them in.

If `omit' is t in a given layout, and the special fields are present
in the order option, no attempt is made to remove them. It also makes
no attempt to handle omit-specs which are functions (since doing this
in the general case would require solving the halting problem).

This variable only takes effect if set before bbdb-expire is loaded."))

;;; Emacs/XEmacs difference workarounds.

(defmacro bbdb-expire-funcall-at-command-loop (func &rest args)
  "Execute FUNCTION at the command loop, passing it ARGS.
That is, do it after control has returned there and Emacs is waiting
for user input."
  ; We only know how to do this for XEmacs, which has `enqueue-eval-event'
  ; with the right semantics. Is this doable in Emacs at all?
  (if (fboundp 'enqueue-eval-event)
      `(enqueue-eval-event
        #'(lambda (-arg) (apply ,func -arg)) (list ,@args))
    `(apply ,func (list ,@args))))

;;; Utility functions and macros.

(defmacro bbdb-expire-without-bbdb-chatter (&rest body)
  "Evaluate BODY suppressing BBDB changed-records and access-time updates.

Useful to call from expiration and preservation predicates."
  `(let ((bbdb-suppress-changed-records-recording t)
         (bbdb-gag-messages t)
         (bbdb-expire-suppress-access-time-update t))
     ,@body))

(defadvice bbdb-update-records (around bbdb-expire-bbdb-notice-changes-only-once-bind activate)
  "Bind a variable that is used to remember if the notice hook has been run."
  (let ((bbdb-expire-bbdb-notice-hook-update-called ()))
    ad-do-it))

(defmacro bbdb-expire-call-only-once (record unique &rest body)
  "Invoke the record-modifying BODY at most once per record display.
To be specific, a call is allowed once per UNIQUE per record display.
(The UNIQUE is normally the calling function, but could be anything.)

Only has an effect when called inside the `bbdb-notice-hook'."
  `(if (or (not (boundp 'bbdb-expire-bbdb-notice-hook-update-called))
           (null (assq ,record bbdb-expire-bbdb-notice-hook-update-called))
           (not (memq ,unique (assq ,record bbdb-expire-bbdb-notice-hook-update-called))))
       (progn
         (unless (not (boundp 'bbdb-expire-bbdb-notice-hook-update-called))
           (if (null (assq ,record bbdb-expire-bbdb-notice-hook-update-called))
               (setq bbdb-expire-bbdb-notice-hook-update-called (nconc bbdb-expire-bbdb-notice-hook-update-called (list (list ,record)))))
           (nconc (assq record bbdb-expire-bbdb-notice-hook-update-called) (list ,unique))
           ,@body))))

(defsubst bbdb-expire-record-putprop (record property newval)
  "Add PROPERTY to RECORD with value NEWVAL.
Unlike `bbdb-record-putprop', this sets the PROPERTY to NEWVAL
iff it is not already set to NEWVAL."
  (if (not (equal (bbdb-record-getprop record property) newval))
      (bbdb-record-putprop record property newval)))

;;; Expiration predicates.

;; `bbdb-expire-record-old-p'.
;; This is the conventional way of doing expiry; records older than
;; `bbdb-expire-this-old' get zapped.

(defun bbdb-expire-initialize-bbdb-expire-record-old-p ()
  "Initialize the `bbdb-expire-record-old-p' predicate.

This involves adding last-access times to the records, and arranging to
update those times. (The predicate is called by default, so there is
no need to arrange to call it here.)"
  (bbdb-expire-add-last-access-time)
  (add-hook 'bbdb-notice-hook 'bbdb-expire-update-last-access-time))

(defun bbdb-expire-update-last-access-time (record)
  "Update the (non-displayed) `last-access' field in the given RECORD.
(The `last-access' field is used by the `bbdb-expire-record-old-p' predicate.)"
  (bbdb-expire-call-only-once record 'bbdb-expire-update-last-access-time
    (or bbdb-expire-suppress-access-time-update
        (bbdb-expire-without-bbdb-chatter
         (bbdb-expire-record-putprop record 'last-access
                                     (format-time-string bbdb-time-internal-format
                                                         (current-time)))))))

(defun bbdb-expire-record-old-p (record)
  "Return t if RECORD is older than `bbdb-expire-this-old' days."
  (let ((last-access (bbdb-record-getprop record 'last-access)))
    (and last-access
         (string< last-access
                  (format-time-string bbdb-time-internal-format
                                      (subtract-time (current-time)
                                                     (days-to-time bbdb-expire-this-old)))))))

(defun bbdb-expire-add-last-access-time ()
  "Add last access times to BBDB records that do not yet have them.
The last access time is set to the current time, because this is safest."
  (interactive)
  ; Do not update last-access timestamps on records that we merely look at.
  (bbdb-expire-without-bbdb-chatter
    ; For all records, add a `last-access' field set to the current time
    ; if that record does not already have one.
    (mapc #'(lambda (record)
              (or (bbdb-record-getprop record 'last-access)
                  (bbdb-record-putprop record 'last-access
                                       (format-time-string bbdb-time-internal-format
                                                           (current-time)))))
          (bbdb-records))))

;; `bbdb-expire-record-single-hit-p'.
;; This zaps records that are older than `bbdb-expire-record-old-p'
;; and which haven't been accessed since they were created.

(defun bbdb-expire-initialize-bbdb-expire-record-single-hit-p ()
  "Initialize the `bbdb-expire-record-single-hit-p' predicate.

This involves arranging to notice that a record is newly created, and
arranging to notice that it's been accessed more than once since that
point."
  (add-hook 'bbdb-create-hook 'bbdb-expire-add-just-created)
  (add-hook 'bbdb-notice-hook 'bbdb-expire-maybe-zap-just-created))

(defun bbdb-expire-add-just-created (record)
  "Add an `expire-just-created' field to the RECORD."
  (bbdb-expire-without-bbdb-chatter
    (bbdb-record-putprop record 'expire-just-created t)))

(defun bbdb-expire-maybe-zap-just-created (record)
  "Possibly zap the `expire-just-created' field from the RECORD.

If the field is t, it's set to 'once (indicating that it's been seen once):
otherwise, it's deleted."
  (bbdb-expire-call-only-once record 'bbdb-expire-maybe-zap-just-created
    (bbdb-expire-without-bbdb-chatter
      (if (eq (bbdb-record-getprop record 'expire-just-created) t)
          (bbdb-record-putprop record 'expire-just-created 'once)
        (bbdb-record-putprop record 'expire-just-created nil)))))

(defun bbdb-expire-record-single-hit-p (record)
  "Return t if the single-hit RECORD is older than a given number of days.

 A `single-hit record' is a record which has only been referenced at creation
time: if it is older than `bbdb-expire-this-old-single-hit' days, this function
returns t on the basis that it is likely a spammer or ask-once-and-go-away
useless newsgroup poster who you have not emailed back."
  (let ((last-access (bbdb-record-getprop record 'last-access))
        (just-created (bbdb-record-getprop record 'expire-just-created)))
    (and last-access
         just-created
         (string< last-access
                  (format-time-string bbdb-time-internal-format
                                      (subtract-time (current-time)
                                                     (days-to-time bbdb-expire-this-old-single-hit)))))))

;; `bbdb-expire-record-noname-p'.

(defun bbdb-expire-record-noname-p (record)
  "Return t if RECORD has no first or last name."
  (and (= 0 (length (bbdb-record-firstname record)))
       (= 0 (length (bbdb-record-lastname record)))))

;; `bbdb-expire-field-{blah}-p': expire if a given field is (or is not)
;; present.

(defun bbdb-expire-record-get-field (record field)
  "Gets a PROPERTY from the given RECORD.
Unlike bbdb-getprop, works on non-properties fields:
unlike bbdb-record-get-field-internal, works on properties fields.
What glorious design BBDB exhibits."
  (if (member field '(name net aka phone address property))
      (bbdb-record-get-field-internal record field)
    (bbdb-record-getprop record field)))

; Generate all these dull predicates with a macro.
; (These predicates are used as `bbdb-expire-preservation-functions' by
;; default, although you could perfectly well generate predicates that
;; were used to force expiry, instead.)

(defmacro bbdb-expire-field-foo-p (field)
  "Generate functions that return t if some RECORD contains a given FIELD.
FIELD should be a quoted symbol, just as passed to `bbdb-record-getprop'."
  `(defun ,@(list (intern (concat "bbdb-expire-field-"
                                  (symbol-name (car (cdr field)))
                                  "-p"))) (record)
     ,@(list (concat "Return t if RECORD contains the `"
                     (symbol-name (car (cdr field))) "' field."))
     (bbdb-expire-record-get-field record ,field)))

(bbdb-expire-field-foo-p 'permanent)
(bbdb-expire-field-foo-p 'notes)

;; Predicate refiling.

;; Handling refiling of multiple records containing a `last-access' or
;; `permanent' field; we pick the string which is lexicographically
;; highest. (Here, we see an advantage of the ISO date format;
;; lexicographic ordering is the same as temporal ordering.)

; When we refile them, we want to sort them lexicographically,
; so we need a function that does that.

(defun bbdb-refile-notes-string-most (string1 string2)
  "Returns the string that is not lessp."
  (if (not (string-lessp string1 string2))
      string1
    string2))

; Arrange to use this function when refiling two records that
; contain these fields.

(setq bbdb-refile-notes-generate-alist
      (append '((last-access . bbdb-refile-notes-string-most)
                (permanent . bbdb-refile-notes-string-most))
              bbdb-refile-notes-generate-alist))

;;; `permanent' field construction.

(defun bbdb-expire-initialize-permanent ()
  "Initialize the `bbdb-expire-make-permanent' feature.

That is, add the workhorse function to the `bbdb-notice-hook',
and optionally initialize the `bbdb-expire-permanent-regexp'
from the `bbdb-expire-permanent-file'."
  (if (and (not bbdb-expire-permanent-regexp)
           bbdb-expire-permanent-file)
      (setq bbdb-expire-permanent-regexp
            (bbdb-expire-permanent-strings-from-file bbdb-expire-permanent-file)))

  ; Mark records permanent if they should be so marked, but are not.
  (let ((bbdb-gag-messages t)
        (bbdb-expire-suppress-access-time-update t))
    ; For all records that are not already marked permanent, if
    ; any function says that it should be marked permanent,
    ; mark it.
    (mapc #'(lambda (record)
              (bbdb-expire-make-permanent record))
          (bbdb-records)))

  (add-hook 'bbdb-notice-hook 'bbdb-expire-make-permanent))

(defun bbdb-expire-permanent-strings-from-file (filename)
  "Load line-delimited strings from FILENAME and turn them into a regexp.
Used to initialize the `bbdb-expire-permanent-regexp' if it is non-nil."
  (condition-case err
      (with-temp-buffer
        (insert-file-contents filename)
        ; Curses. `buffer-string' always sticks an LF on the end; we must
        ; cut it out again, lest our regexp match *everything*.
        (regexp-opt (delete "" (split-string (buffer-string) "\n"))))
    ; If there's an error, signal it once we're back at the
    ; command loop, overwriting any mere progress reports
    ; that may have been displayed in the meantime.
    (file-error (bbdb-expire-funcall-at-command-loop
                 #'(lambda (conditions data)
                     (signal conditions data))
                 (car err) (cdr err))
                nil)))

(defun bbdb-expire-make-permanent (record)
  "Possibly make the RECORD permanent.
The record is made permanent if at least one of the
`bbdb-expire-make-permanent-functions' returns non-nil."
  (bbdb-expire-call-only-once record 'bbdb-expire-make-permanent
    (let ((bbdb-gag-messages t)
          (bbdb-expire-suppress-access-time-update t))
      (if (and (not (bbdb-record-getprop record 'permanent))
               (run-hook-with-args-until-success
                'bbdb-expire-make-permanent-functions record))
          (bbdb-record-putprop record 'permanent "t")))))

(defun bbdb-expire-permanent-address-matches-p (record)
  "Return t if RECORD matches the `bbdb-expire-permanent-regexp'."
  (and bbdb-expire-permanent-regexp
       (find-if #'(lambda (address)
                    (and address
                         (string-match bbdb-expire-permanent-regexp address)))
                (bbdb-record-net record))))

;;; Core code.

;; Initialize: arrange to not show last-access times, run the
;; initialization hooks, and run an expiry.

(defvar bbdb-expire-auto-expiry-timer nil
  "Timer used to automatically expire the BBDB, or nil if none.")

(defun bbdb-expire-initialize ()
  "Initialize the BBDB expiry package and run an initial expiry."
  (bbdb-expire-auto-edit-bbdb-display-layout-alist)
  (run-hooks 'bbdb-expire-initialize-hook)
  (setq bbdb-message-caching-enabled nil)
  (bbdb-expire-set-automatic-interval bbdb-expire-automatic-interval)
  (bbdb-expire-bbdb))

;; Apply the requested automatic hides.
;; (In BBDB-2.32, just hide both the variables unconditionally.)

(defun bbdb-expire-auto-edit-bbdb-display-layout-alist ()
  "Automatically edit the `bbdb-display-layout-alist',
applying the transformations in the `bbdb-expire-autohide-variables'.
For BBDB-2.32 and below, merely add the `last-access' and `permanent'
fields to `bbdb-elided-display'."
  (cond
   ((boundp 'bbdb-display-layout-alist)
    (mapc                                 ; Iterate over vars to hide
     #'(lambda (hide-var)
         (mapc                            ; Iterate over layouts to hide them in
          #'(lambda (hide-layout)
              (let ((layout (assq hide-layout bbdb-display-layout-alist)))
                (if layout               ; Existing layout?
                    (let ((omit-option (assq 'omit layout)))
                      (if omit-option    ; Already has an omit clause?
                          (if (and (not (functionp (cdr omit-option)))
                                   (not (memq (car hide-var) omit-option))
                                   (not (eq t (cdr omit-option))))
                              (nconc omit-option (cons (car hide-var) nil)))
                        (nconc layout (cons (list 'omit (car hide-var)) nil))))
                  (setq bbdb-display-layout-alist
                        (nconc bbdb-display-layout-alist
                               (cons (list hide-layout (list 'omit (car hide-var))) nil))))))
          (nth 1 hide-var)))
     bbdb-expire-autohide-variables))
   ;; Primitive, lesser BBDB; 2.32 or below.
   (t
    (setq bbdb-elided-display (nconc bbdb-elided-display '(last-access permanent))))))

;; Expiry.

(defun bbdb-expire-set-automatic-interval (interval)
  "Set the interval between automatic expiry runs, and start counting anew.

An interval of zero disables automatic expiry."
  (interactive "nSeconds between expiries: ")
  (if bbdb-expire-auto-expiry-timer
      (cancel-timer bbdb-expire-auto-expiry-timer))
  (if (eq interval 0)
      (setq bbdb-expire-auto-expiry-timer nil)
    (setq bbdb-expire-auto-expiry-timer
          (run-with-timer interval interval 'bbdb-expire-bbdb))))

(defun bbdb-expire-bbdb ()
  "Expire old records from the BBDB.
Entries are expired if at least one of the `bbdb-expire-expiry-functions'
returns non-nil, and none of the `bbdb-expire-preservation-functions'
return non-nil."
  (interactive)
  (run-hooks 'bbdb-expire-pre-expire-hook)
  ; Do not fire hooks and update timestamps on records that we merely look at.
  (bbdb-expire-without-bbdb-chatter
    (bbdb-records)
    ; For all records, if the record should be expired, and fails
    ; all attempts at its preservation, delete it.
    (mapc #'(lambda (record)
              (and (run-hook-with-args-until-success
                    'bbdb-expire-expiry-functions record)
                   (not (run-hook-with-args-until-success
                         'bbdb-expire-preservation-functions record))
                   (bbdb-delete-record-internal record)))
          (bbdb-records)))
  (run-hooks 'bbdb-expire-post-expire-hook))

(run-hooks 'bbdb-expire-load-hook)

(provide 'bbdb-expire)
